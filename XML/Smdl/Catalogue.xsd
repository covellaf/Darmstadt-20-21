<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:xhtml="http://www.w3.org/1999/xhtml"
            xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore"
            xmlns:Catalogue="http://www.ecss.nl/smp/2019/Smdl/Catalogue"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            xmlns:Types="http://www.ecss.nl/smp/2019/Core/Types"
            xmlns:Elements="http://www.ecss.nl/smp/2019/Core/Elements"
            xmlns="http://www.ecss.nl/smp/2019/Smdl/Catalogue"
            targetNamespace="http://www.ecss.nl/smp/2019/Smdl/Catalogue"
            elementFormDefault="unqualified"
            attributeFormDefault="unqualified"
            ecore:package="smdl.catalogue"
            ecore:nsPrefix="Catalogue"
            ecore:documentRoot="CatalogueDocumentRoot">
   <xsd:annotation>
      <xsd:documentation>This schema defines all metamodel elements that are needed in order to define models in a catalogue. Catalogues make use of the mechanisms defined in Core Types, e.g. enumerations and structures, and they add reference types (interfaces and components), events and a hierarchical grouping mechanism (namespaces).</xsd:documentation>
      <xsd:documentation>
This file is generated by the UMF XML Schema Generation Tool, version 2.1.0.qualifier.

UML Model Information:
    UML model file:  file:/C:/Data/Projects/ECSS16/Software/Windows/pfritzen/SMP/Src/ecss.smp.smdl/target/xmi/ecss.smp.smdl.xmi
    UML model name:  Obsolete
    UML metamodel:   http://schema.omg.org/spec/UML/2.2
    XMI version:     2.1
    XMI exporter:    UMF XMI Converter (from MagicDraw UML 17.0.2), version 2.1.0.qualifier

XSLT Processing Information:
    Processing date: 2019-10-28T17:05:22.729+01:00
    XSLT processor:  SAXON 8.8.0.7 from Saxonica
    XSLT version:    2.0
    XSLT stylesheet: xmi-to-xsd.xslt
      </xsd:documentation>
   </xsd:annotation>
   <!-- Import UML Component 'xlink' -->
   <xsd:import namespace="http://www.w3.org/1999/xlink" schemaLocation="../xlink.xsd">
      <xsd:annotation>
         <xsd:documentation>Schema for the W3C XML Linking Language (XLink).</xsd:documentation>
      </xsd:annotation>
   </xsd:import>
   <!-- Import UML Component 'Core::Types' -->
   <xsd:import namespace="http://www.ecss.nl/smp/2019/Core/Types"
               schemaLocation="../Core/Types.xsd">
      <xsd:annotation>
         <xsd:documentation>This schema provides basic types and typing mechanisms, together with appropriate value specification mechanisms.</xsd:documentation>
      </xsd:annotation>
   </xsd:import>
   <!-- Import UML Component 'Core::Elements' -->
   <xsd:import namespace="http://www.ecss.nl/smp/2019/Core/Elements"
               schemaLocation="../Core/Elements.xsd">
      <xsd:annotation>
         <xsd:documentation>This schema defines base metaclasses and annotation mechanisms used throughout the SMP Metamodel.</xsd:documentation>
      </xsd:annotation>
   </xsd:import>

   <!-- ======================================== -->
   <!-- UML Package 'Catalogue' -->
   <!-- ======================================== -->
   <!-- This package describes all metamodel elements that are needed in order to define models in a catalogue. Catalogues make use of the mechanisms defined in Core Types, e.g. enumerations and structures, and they add reference types (interfaces and components), events and a hierarchical grouping mechanism (namespaces). -->

   <!-- UML InstanceSpecification 'Catalogue' -->
   <xsd:element name="Catalogue" type="Catalogue:Catalogue">
      <xsd:annotation>
         <xsd:documentation>The Catalogue element (of type Catalogue) is the root element of an SMDL catalogue.</xsd:documentation>
      </xsd:annotation>
   </xsd:element>

   <!-- ======================================== -->
   <!-- UML Package 'Catalogue::Catalogue' -->
   <!-- ======================================== -->
   <!-- A catalogue contains namespaces, which themselves contain other namespaces and types. Types can either be language types, attribute types (both defined in Core Types) or event types. Further, catalogues extend the available language types by reference types (interfaces and components). -->

   <!-- UML Class 'Catalogue' -->
   <xsd:complexType name="Catalogue">
      <xsd:annotation>
         <xsd:documentation>A Catalogue is a document that defines types. It contains namespaces as a primary ordering mechanism. The names of these namespaces need to be unique within the catalogue.</xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Elements:Document">
            <xsd:sequence>
               <xsd:element name="Namespace" type="Catalogue:Namespace" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of namespaces of the catalogue.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
            </xsd:sequence>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- UML Class 'Namespace' -->
   <xsd:complexType name="Namespace">
      <xsd:annotation>
         <xsd:documentation>A Namespace is a primary ordering mechanism. A namespace may contain other namespaces (nested namespaces), and does typically contain types. In SMDL, namespaces are contained within a Catalogue (either directly, or within another namespace in a catalogue).
All sub-elements of a namespace (namespaces and types) must have unique names.</xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Elements:NamedElement">
            <xsd:sequence>
               <xsd:element name="Namespace" type="Catalogue:Namespace" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of nested namespaces of the namespace.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
               <xsd:element name="Type" type="Types:Type" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of types defined within the namespace.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
            </xsd:sequence>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- ======================================== -->
   <!-- UML Package 'Catalogue::Reference Types' -->
   <!-- ======================================== -->
   <!-- An instance of a reference type is uniquely determined by a reference to it, and may have internal state. Two instances of a reference type are equal if and only if they occupy the same (memory) location, i.e. if the references to them are identical. Two instances with equal values may therefore not be equal if they occupy different (memory) locations. Reference types include interfaces and components (models and services).
Every reference type supports properties and operations. A component adds a number of features for different purposes. First, it adds fields to store an internal state, and provided interfaces for interface-based programming. Further, it adds mechanisms to describe dependencies on other reference types, event sources and sinks for event-based programming, and entry points to allow calling void functions e.g. from a scheduler. -->

   <!-- UML Class 'ReferenceType' -->
   <xsd:complexType name="ReferenceType" abstract="true">
      <xsd:annotation>
         <xsd:documentation>
            <xhtml:p> ReferenceType serves as an abstract base metaclass for Interface and Component. An instance of a ReferenceType is identified by a reference to it - as opposed to an instance of a ValueType which is identified by its value. A reference type may have various optional elements: <xhtml:ul>
                  <xhtml:li> Constant elements specify constants defined in the reference type&apos;s name scope; </xhtml:li>
                  <xhtml:li> Property elements specify the reference type&apos;s properties; and </xhtml:li>
                  <xhtml:li> Operation elements specify the reference type&apos;s operations. </xhtml:li>
               </xhtml:ul>
            </xhtml:p>
         </xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Types:LanguageType">
            <xsd:sequence>
               <xsd:element name="Constant" type="Types:Constant" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of constants.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
               <xsd:element name="Property" type="Types:Property" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of properties.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
               <xsd:element name="Operation" type="Types:Operation" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of operations.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
            </xsd:sequence>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- UML Class 'Component' -->
   <xsd:complexType name="Component" abstract="true">
      <xsd:annotation>
         <xsd:documentation>
            <xhtml:p> A Component is a reference type and hence inherits the ability to hold constants, properties and operations. As a Component semantically forms a deployable unit, it may use the available object and component mechanisms of the standard. Apart from the ability to specify a Base component (single implementation inheritance), a component may have various optional elements: <xhtml:ul>
                  <xhtml:li> Interface links specify interfaces that the component provides (in SMP this implies that the component implements these interfaces); </xhtml:li>
                  <xhtml:li> EntryPoint elements allow the component to be scheduled (via the Scheduler service) and to listen to global events (via the EventManager service); </xhtml:li>
                  <xhtml:li> EventSink elements specify which events the component can receive (these may be registered with other components&apos; event sources); </xhtml:li>
                  <xhtml:li> EventSource elements specify events that the component can emit (other components may register their associated event sink(s) with these); </xhtml:li>
                  <xhtml:li> Field elements define a component&apos;s internal state; and </xhtml:li>
                  <xhtml:li> Association elements express associations to other components or fields of other components. </xhtml:li>
                  <xhtml:li> Container elements define containment of other components (composition). </xhtml:li>
                  <xhtml:li> Reference elements define reference to other components (aggregation). </xhtml:li>
               </xhtml:ul>
            </xhtml:p>
         </xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Catalogue:ReferenceType">
            <xsd:sequence>
               <xsd:element name="Base" minOccurs="0">
                  <xsd:annotation>
                     <xsd:documentation>Base component, which is optional.</xsd:documentation>
                     <xsd:documentation>Link destination type: Catalogue:Component</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Catalogue:Component</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="BaseOfComponent">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="Component"
                                    ecore:reference="Catalogue:Component"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="ComponentName"/>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="Interface" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of provided interfaces.</xsd:documentation>
                     <xsd:documentation>Link destination type: Catalogue:Interface</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Catalogue:Interface</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="InterfaceOfComponent">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="Interface"
                                    ecore:reference="Catalogue:Interface"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="InterfaceName"/>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="EntryPoint" type="Catalogue:EntryPoint" minOccurs="0"
                            maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of entry points.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
               <xsd:element name="EventSink" type="Catalogue:EventSink" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of event sinks.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
               <xsd:element name="EventSource" type="Catalogue:EventSource" minOccurs="0"
                            maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of event sources.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
               <xsd:element name="Field" type="Types:Field" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of fields.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
               <xsd:element name="Association" type="Types:Association" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of associations.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
               <xsd:element name="Container" type="Catalogue:Container" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of containers.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
               <xsd:element name="Reference" type="Catalogue:Reference" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of references.</xsd:documentation>
                  </xsd:annotation>
               </xsd:element>
            </xsd:sequence>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- UML Class 'Interface' -->
   <xsd:complexType name="Interface">
      <xsd:annotation>
         <xsd:documentation>An Interface is a reference type that serves as a contract in a loosely coupled architecture. It has the ability to contain constants, properties and operations (from ReferenceType). An Interface may inherit from other interfaces (interface inheritance), which is represented via the Base links.</xsd:documentation>
         <xsd:documentation>
            <xhtml:p>
               <xhtml:i>
                  <xhtml:b> Remark </xhtml:b>
               </xhtml:i> : It is strongly recommended to only use value types, references and other interfaces in the properties and operations of an interface (i.e. not to use models). Otherwise, a dependency between a model implementing the interface, and other models referenced by this interface is introduced, which is against the idea of interface-based or component-based design. </xhtml:p>
         </xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Catalogue:ReferenceType">
            <xsd:sequence>
               <xsd:element name="Base" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of base interfaces.</xsd:documentation>
                     <xsd:documentation>Link destination type: Catalogue:Interface</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Catalogue:Interface</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="BaseOfInterface">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="Interface"
                                    ecore:reference="Catalogue:Interface"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="InterfaceName"/>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- UML Class 'Model' -->
   <xsd:complexType name="Model">
      <xsd:annotation>
         <xsd:documentation>The Model metaclass is a component and hence inherits all component mechanisms.
These mechanisms allow using various different modelling approaches.
For a class-based design, a Model may provide a collection of Field elements to define its internal state. For scheduling and global events, a Model may provide a collection of EntryPoint elements that can be registered with the Scheduler or EventManager services of a Simulation Environment.
For an interface-based design, a Model may provide (i.e. implement) an arbitrary number of interfaces, which is represented via the Interface links.
For a component-based design, a Model may provide Container elements to contain other models (composition), and Reference elements to reference other components (aggregation). These components can either be models or services.
For an event-based design, a Model may support inter-model events via the EventSink and EventSource elements.
For a dataflow-based design, the fields of a Model can be tagged as Input or Output fields.
In addition, a Model may have Association elements to express associations to other models or fields of other models.</xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Catalogue:Component"/>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- UML Class 'Service' -->
   <xsd:complexType name="Service">
      <xsd:annotation>
         <xsd:documentation>The Service metaclass is a component and hence inherits all component mechanisms. A Service can reference one or more interfaces via the Interface links (inherited from Component), where at least one of them must be derived from Smp::IService, which qualifies it as a service interface.
</xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Catalogue:Component"/>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- ======================================== -->
   <!-- UML Package 'Catalogue::Modelling Mechanisms' -->
   <!-- ======================================== -->
   <!-- This section describes the different modelling mechanisms. -->

   <!-- ======================================== -->
   <!-- UML Package 'Catalogue::Modelling Mechanisms::Class based Design' -->
   <!-- ======================================== -->
   <!-- This section describes modelling mechanisms for a class based design. -->

   <!-- UML Class 'EntryPoint' -->
   <xsd:complexType name="EntryPoint">
      <xsd:annotation>
         <xsd:documentation>An EntryPoint is a named element of a Component (Model or Service). It corresponds to a void operation taking no parameters that can be called from an external client (e.g. the Scheduler or Event Manager services). An Entry Point can reference both Input fields (which must have their Input attribute set to true) and Output fields (which must have their Output attribute set to true). These links can be used to ensure that all component output fields are updated before the entry point is called, or that all input fields can be used after the entry point has been called.</xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Elements:NamedElement">
            <xsd:sequence>
               <xsd:element name="Input" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of input fields of components that are updated by calls to this entry point, and hence can be used after calling the entry point.</xsd:documentation>
                     <xsd:documentation>Link destination type: Types:Field</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Types:Field</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="InputOfEntryPoint">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="Field"
                                    ecore:reference="Types:Field"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="FieldName"/>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="Output" minOccurs="0" maxOccurs="unbounded">
                  <xsd:annotation>
                     <xsd:documentation>Collection of output fields of components that are read during calls to this entry point, and hence have to be updated prior to calling the entry point.</xsd:documentation>
                     <xsd:documentation>Link destination type: Types:Field</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Types:Field</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="OutputOfEntryPoint">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="Field"
                                    ecore:reference="Types:Field"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="FieldName"/>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- ======================================== -->
   <!-- UML Package 'Catalogue::Modelling Mechanisms::Component based Design' -->
   <!-- ======================================== -->
   <!-- This section describes modelling mechanisms for a component based design. -->

   <!-- UML Class 'Container' -->
   <xsd:complexType name="Container">
      <xsd:annotation>
         <xsd:documentation>A Container defines the rules of composition (containment of children) for a Component.
The type of components that can be contained is specified via the Type link.
The Lower and Upper attributes specify the multiplicity, i.e. the number of possibly stored components. Therein the upper bound may be unlimited, which is represented by Upper=-1. 
Furthermore, a container may specify a default implementation of the container type via the DefaultComponentl link.</xsd:documentation>
         <xsd:documentation>
            <xhtml:p>
               <xhtml:b>
                  <xhtml:i> Remark </xhtml:i>
               </xhtml:b> : SMDL support tools may use this during instantiation (i.e. during model integration) to select an initial implementation for newly created contained components. </xhtml:p>
         </xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Elements:NamedElement">
            <xsd:sequence>
               <xsd:element name="Type">
                  <xsd:annotation>
                     <xsd:documentation>Type that all components in this container have to be of, or be derived of.</xsd:documentation>
                     <xsd:documentation>Link destination type: Catalogue:ReferenceType</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Catalogue:ReferenceType</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="TypeOfContainer">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="ReferenceType"
                                    ecore:reference="Catalogue:ReferenceType"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="ReferenceTypeName"/>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="DefaultComponent" minOccurs="0">
                  <xsd:annotation>
                     <xsd:documentation>Default component for a child of the container.</xsd:documentation>
                     <xsd:documentation>Link destination type: Catalogue:Component</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Catalogue:Component</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="DefaultComponentOfContainer">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="Component"
                                    ecore:reference="Catalogue:Component"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="ComponentName"/>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="Lower" type="xsd:long" use="optional" default="1">
               <xsd:annotation>
                  <xsd:documentation>Lower limit of components in the container.</xsd:documentation>
               </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="Upper" type="xsd:long" use="optional" default="1">
               <xsd:annotation>
                  <xsd:documentation>Upper limit of components in the container.</xsd:documentation>
               </xsd:annotation>
            </xsd:attribute>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- UML Class 'Reference' -->
   <xsd:complexType name="Reference">
      <xsd:annotation>
         <xsd:documentation>A Reference defines the rules of aggregation (links to components) for a Component.
The type of components (models or services) that can be referenced is specified by the Interface link. Thereby, a service reference is characterized by an interface that is derived from Smp::IService.
The Lower and Upper attributes specify the multiplicity, i.e. the number of possibly held references to components implementing this interface. Therein the upper bound may be unlimited, which is represented by Upper=-1.</xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Elements:NamedElement">
            <xsd:sequence>
               <xsd:element name="Interface">
                  <xsd:annotation>
                     <xsd:documentation>Interface that all components linked to from this reference have to implement.</xsd:documentation>
                     <xsd:documentation>Link destination type: Catalogue:Interface</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Catalogue:Interface</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="InterfaceOfReference">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="Interface"
                                    ecore:reference="Catalogue:Interface"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="InterfaceName"/>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="Lower" type="xsd:long" use="optional" default="1">
               <xsd:annotation>
                  <xsd:documentation>Lower limit of component links in the reference.</xsd:documentation>
               </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="Upper" type="xsd:long" use="optional" default="1">
               <xsd:annotation>
                  <xsd:documentation>Upper limit of component links in the reference.</xsd:documentation>
               </xsd:annotation>
            </xsd:attribute>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- ======================================== -->
   <!-- UML Package 'Catalogue::Modelling Mechanisms::Event based Design' -->
   <!-- ======================================== -->
   <!-- This section describes modelling mechanisms for an event based design. -->

   <!-- UML Class 'EventType' -->
   <xsd:complexType name="EventType">
      <xsd:annotation>
         <xsd:documentation>An EventType is used to specify the type of an event. This can be used not only to give a meaningful name to an event type, but also to link it to an existing simple type (via the EventArgs attribute) that is passed as an argument with every invocation of the event.</xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Types:Type">
            <xsd:sequence>
               <xsd:element name="EventArgs" minOccurs="0">
                  <xsd:annotation>
                     <xsd:documentation>Type of the event argument, or none for a void event.</xsd:documentation>
                     <xsd:documentation>Link destination type: Types:SimpleType</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Types:SimpleType</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="EventArgsOfEventType">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="SimpleType"
                                    ecore:reference="Types:SimpleType"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="SimpleTypeName"/>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- UML Class 'EventSource' -->
   <xsd:complexType name="EventSource">
      <xsd:annotation>
         <xsd:documentation>An EventSource is used to specify that a Component publishes a specific event under a given name. The Multicast attribute can be used to specify whether any number of sinks can connect to the source (the default), or only a single sink can connect (Multicast=false).</xsd:documentation>
         <xsd:documentation>
            <xhtml:p>
               <xhtml:b>
                  <xhtml:i> Remark </xhtml:i>
               </xhtml:b> : A tool for model integration can use the Multicast attribute to configure the user interface accordingly to ease the specification of event links. </xhtml:p>
         </xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Elements:NamedElement">
            <xsd:sequence>
               <xsd:element name="Type">
                  <xsd:annotation>
                     <xsd:documentation>Type of the event.</xsd:documentation>
                     <xsd:documentation>Link destination type: Catalogue:EventType</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Catalogue:EventType</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="TypeOfEventSource">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="EventType"
                                    ecore:reference="Catalogue:EventType"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="EventTypeName"/>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="Multicast" type="xsd:boolean" use="optional" default="true">
               <xsd:annotation>
                  <xsd:documentation>True if the event source supports multi-cast, false otherwise.</xsd:documentation>
               </xsd:annotation>
            </xsd:attribute>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <!-- UML Class 'EventSink' -->
   <xsd:complexType name="EventSink">
      <xsd:annotation>
         <xsd:documentation>An EventSink is used to specify that a Component can receive a specific event using a given name. An EventSink can be connected to any number of EventSource instances.</xsd:documentation>
      </xsd:annotation>
      <xsd:complexContent>
         <xsd:extension base="Elements:NamedElement">
            <xsd:sequence>
               <xsd:element name="Type">
                  <xsd:annotation>
                     <xsd:documentation>Type of the event.</xsd:documentation>
                     <xsd:documentation>Link destination type: Catalogue:EventType</xsd:documentation>
                     <xsd:appinfo source="http://www.w3.org/1999/xlink">Catalogue:EventType</xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType ecore:name="TypeOfEventSink">
                     <xsd:attribute ref="xlink:type" use="prohibited" fixed="simple"/>
                     <xsd:attribute ref="xlink:href" use="required" ecore:name="EventType"
                                    ecore:reference="Catalogue:EventType"/>
                     <xsd:attribute ref="xlink:title" use="optional" ecore:name="EventTypeName"/>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>
</xsd:schema>